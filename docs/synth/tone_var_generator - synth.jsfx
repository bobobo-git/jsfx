// License: GPL - http://www.gnu.org/licenses/gpl-3.0.html
desc: tone_variable_generator
//tags: sine generator synthesis
//author: bobobo , from code by Drake Andersen

slider1:440<0,880,27.5>Fundamental Frequency (Hz)
slider2:-12<-120,0,1>F1 Volume (dB)
slider3:12<1,24,1>divider
slider4:12<0,24,1>counts

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import add.array.jsfx-inc
@init
poly.array_init(0, 128, 4+8); // [0note, 1velocity, 2freq, 3phase, 4..12 phase_unison]
midi.array_init(11000, 256, 4); // [offset, msg1, note, vel]
hold.array_init(13000, 128, 1); // [note] mono hold notes array

@slider
vol1=2 ^ (slider2/6);


f0=slider1;
fn = f0 * pow(2,((slider4)/slider3));

adj1 = 2.0*$pi*(fn)/srate;

@block
// remove queued midi messages that have been processed
ptr = midi.array_first();
while (ptr >= 0) (
  ptr[0] < 0 ? (
    midi.array_remove(ptr);
    ptr = midi.array_first();
  ) : (
    ptr = midi.array_next(ptr);
  );
);

// remove notes that finished adsr
ptr = poly.array_first();
while (ptr >= 0) (
  env = mono ? envelope : envelope + ptr[0] * 7;
  env[5] == 0 ? (
    poly.array_remove(ptr);
    ptr = poly.array_first();
  ) : (
    ptr = poly.array_next(ptr);
  );
);

while (midirecv(offset, msg1, note, vel)) (
  event = msg1 & 0xF0;
  channel = msg1 & 0x0F;

  // note on/off
  event == 0x90 || event == 0x80 ? (
    midi.size == 256 ? ( // prevent midi buffer overflow
      midi.array_remove(midi.array_first());
    );
    ptr = midi.array_add();
    ptr[0] = offset;
    ptr[1] = msg1;
    ptr[2] = note;
    ptr[3] = vel
  );

  // All notes off
  event == 0xB0 && note == 123 ? (
    poly.array_clear();
    hold.array_clear();
  );

  midisend(offset, msg1, note, vel);
);


@sample
tone1 = Cos(pos1);
tone1 *= vol1;
spl0 = tone1;
spl1 = tone1;
pos1 += adj1;
(pos1 >= 2.0*$pi) ? pos1 -= 2.0*$pi;

