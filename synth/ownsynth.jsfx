desc:ownsynth (simple synth bobobo)
// bobobo , as usual standing on shoulders of giants

// bobobo made a very simple synth with the help of the fabulous stuff from Geraint Luff, Schwa and  Thomas Scott Stillwell
// geraint Luff for the synth part , took from https://forum.cockos.com/showthread.php?t=188191 or https://github.com/geraintluff/jsfx/blob/master/synth-framework.jsfx-inc
// schwa for the Soft Clipper/Limiter (will be delivered with REAPER)
// Thomas Scott Stillwell for the RBJ Highpass/Lowpass Filters [Stillwell]  (will be delivered with REAPER)
// the filter is here a low snd highpass (Effects/Witti/lphpbp_resonant) from witti (you'll find it in the REAPER forum)
// or here https://github.com/Samelot/Reaper/blob/master/Effects/Witti/lphpbp_resonant
// to prevent overshoots i put the soft_clipper
// and to get arround soundissues i applied the RBJ Highpass/Lowpass Filters
// i tried to make a nice gui but as this would increase cpu cycles (not much but measureable) i stopped this for now

slider1:attack=0.01<0,5,0.001:sqr=2>attack

//slider2:sustains=0.05<0,2,0.001>sustain Seconds

slider2:release=0.01<0,10,0.001:sqr=2>release
//slider oscs
slider7:sineV=0<0,1,0.001:sqr=2>Vol Sine
slider8:sawV=0<0,1,0.001:sqr=2>Vol Saw
slider9:squareV=0<0,1,0.001:sqr=2>Vol Square
slider10:triV=0<0,1,0.001:sqr=2>Vol Triangle
//supslider
slider13:supV=0<0,1,0.001:sqr=1>Vol Sup
slider14:supset=2<2,4,2>Sup Octave
//subslider
slider15:subV=0<0,1,0.001:sqr=2>Vol Sub
slider16:subset=2<2,4,2>Sub Octave
//pitchbewnd_range
slider18:pbrange=2<1,48,1>PitchBendRange (reset synth)
//slider for the HP LF Filter
slider20:hpff=0<0,5000,0.01:log=1000>HP Frequency (Hz)
slider21:hpfr=0<0,1,0.001:sqr=0.25>HP Resonance
//slider for the LP LF Filter
slider22:lpff=16000<0,16000,0.01:log=1000>LP Frequency (Hz) //max 16000
slider23:lpfr=0<0,1,0.001:sqr=0.25>LP Resonance
//slider for the Clipper
slider30:cl_boost=0<-24,24,0.1:sqr=2>Boost (dB)
slider31:cl_wall=0<-12,1,0.1>Output Brickwall (dB)

in_pin:none
out_pin:Left
out_pin:Right

/* Generated by: JSFX Pre-Processor (https://github.com/geraintluff/jsfx-preprocessor) */
@init

function synth_reset_controllers() local(i) (
  synthx_pitchbend = 0;
  synthx_pitchbend_ratio = 1;

  i = 0;
  while (i < 128) (
    (i == 7 || i == 10 || (i >= 91 && i <= 95) || (i >= 70 && i <= 79) || i >= 120) ? (
      0; // These don't get reset
    ) : (i >= 98 && i <= 101) ? (
      synthx_controllers[i] = 127;
    ) : (i != 0 && i != 32) ? (
      synthx_controllers[i] = 0;
    );
    i += 1;
  );
  synthx_controllers[11] = 127;
);

function synth_option_midi_sink(value) (
  synthx_midi_sink = value;
);

function synth_setup(freemem, custom_slots, pbrange) local(i) (
  synthx_polyphony = 16;
  synthx_custom_offset = 9/*NOTE: ACTIVE, SAMPLES_FROM_RELEASE, SAMPLES_FROM_ATTACK, SAMPLES_FROM_SUSTAIN_RELEASE, NOTE, BASE_FREQ, VEL, CHANNEL, CUSTOM_INIT*/;
  synthx_timestep = 1/srate;
  synthx_step = synthx_custom_offset + custom_slots;
  synthx_maxduration = 60*60*24*365*srate; // one year
  synthx_pitchbend = 0;
  synthx_pitchbend_ratio = 1;
  synthx_pitchbend_range = pbrange;

  synthx_max_active_note = 0;
  synthx_current_note = 0;
  freemem = (synthx_controllers = freemem) + 128;
  freemem = (synthx_notestack = freemem) + synthx_polyphony*synthx_step;

  synth_reset_controllers();
  i = 0;
  while (i < synthx_polyphony*synthx_step) (
    synthx_notestack[i] = 0;
    i += 1;
  );
  freemem;
);

function synth_init(freemem, custom_slots,pbrange) (
  synth_setup(freemem, custom_slots,pbrange);
);

function synth_block() local(midi_offset, midi_msg1, midi_msg23, midi_msg2, midi_msg3, midi_type, midi_channel, i, note, selected_note) (
  while (midirecv(midi_offset, midi_msg1, midi_msg23)) (
    !synthx_midi_sink ? (
      midisend(midi_offset, midi_msg1, midi_msg23); // passthrough
    );
    midi_type = midi_msg1>>4;
    midi_channel = midi_msg1&0x0f;
    midi_msg2 = midi_msg23&$xff; // note / controller
    midi_msg3 = midi_msg23>>8; // velocity / value
    (midi_type == $x9 && midi_msg3 != 0) ? (
      // Note on
      selected_note = -1;
      // Choose inactive note
      i = 0;
      while (i < synthx_polyphony && selected_note < 0) (
        note = synthx_notestack + synthx_step*i;
        !note[0/*NOTE:ACTIVE*/] ? (
          selected_note = note;
        );
        i += 1;
      );
      // If we didn't find one, stop a release
      selected_note < 0 ? (
        // Start by selecting random index
        i = floor(rand()*synthx_polyphony);
        selected_note = synthx_notestack + synthx_step*i;
        // Choose note with longest release phase
        i = 0;
        while (i < synthx_polyphony && selected_note < 0) (
          note = synthx_notestack + synthx_step*i;
          note[1/*NOTE:SAMPLES_FROM_RELEASE*/] > selected[1/*NOTE:SAMPLES_FROM_RELEASE*/] ? (
            selected_note = note;
          );
          i += 1;
        );
      );
      // Reset the custom note parameters to 0
      i = synthx_custom_offset;
      while (i < synthx_step) (
        selected_note[i] = 0;
        i += 1;
      );
      // Set up the note parameters
      selected_note[0/*NOTE:ACTIVE*/] = 1;
      selected_note[2/*NOTE:SAMPLES_FROM_ATTACK*/] = -midi_offset;
      selected_note[1/*NOTE:SAMPLES_FROM_RELEASE*/] = -synthx_maxduration;
      selected_note[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/] = -synthx_maxduration;
      selected_note[4/*NOTE:NOTE*/] = midi_msg2;
      selected_note[5/*NOTE:BASE_FREQ*/] = 440*pow(2, (midi_msg2 - 69)/12);
      selected_note[6/*NOTE:VEL*/] = midi_msg3;
      selected_note[7/*NOTE:CHANNEL*/] = midi_channel;
      selected_note[8/*NOTE:CUSTOM_INIT*/] = 0;
    ) : (midi_type == $x8 || (midi_type == $x9 && midi_msg3 == 0)) ? (
      // Choose duplicate note if there is one
      i = 0;
      while (i < synthx_polyphony) (
        note = synthx_notestack + synthx_step*i;
        note[4/*NOTE:NOTE*/] == midi_msg2 ? (
          note[1/*NOTE:SAMPLES_FROM_RELEASE*/] = max(note[1/*NOTE:SAMPLES_FROM_RELEASE*/], -midi_offset);
          note[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/] = max(note[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/], -midi_offset);
        );
        i += 1;
      );
    ) : (midi_type == 11) ? (
      // Controller
      midi_msg2 == 121 ? (
        synth_reset_controllers();
      ) : midi_msg2== 123 ? (
        // stop all notes (with release)
        i = 0;
        while (i < synthx_polyphony) (
          note = synthx_notestack + synthx_step*i;
          note[1/*NOTE:SAMPLES_FROM_RELEASE*/] = max(note[1/*NOTE:SAMPLES_FROM_RELEASE*/], 0);
          note[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/] = max(note[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/], 0);
          i += 1;
        );
      ) : midi_msg2== 120 ? (
        // stop all notes (no release)
        i = 0;
        while (i < synthx_polyphony) (
          note = synthx_notestack + synthx_step*i;
          note[0/*NOTE:ACTIVE*/] = 0;
          i += 1;
        );
      ) : (
        synthx_controllers[midi_msg2] = midi_msg3;
      );
    ) : (midi_type == 14) ? (
      synthx_pitchbend = (midi_msg3*128 + midi_msg2) - 8192;
      synthx_pitchbend_ratio = pow(2, synthx_pitchbend_range/12*synthx_pitchbend/8192);
    );
  );
  synthx_max_active_note = -1;
  i = 0;
  note = synthx_notestack;
  while (i < synthx_polyphony) (
    note[0/*NOTE:ACTIVE*/] ? (
      synthx_max_active_note = i;
    );
    i += 1;
    note += synthx_step;
  );
  synthx_max_active_note + 1;
);

function synth_sample() local(i, note, have_active) (
  i = 0;
  while (i <= synthx_max_active_note) (
    note = synthx_notestack + synthx_step*i;
    note[0/*NOTE:ACTIVE*/] ? (
      note[2/*NOTE:SAMPLES_FROM_ATTACK*/] += 1;
      note[1/*NOTE:SAMPLES_FROM_RELEASE*/] += 1;
      synthx_controllers[64] < 64 ? (
        note[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/] += 1;
      );
    );
    i += 1;
  );
);

function synth_note_next(note) local(selected_note, index, note) (
  index = floor((note - synthx_custom_offset - synthx_notestack)/synthx_step);
  index < 0 ? (
    index = 0;
  ) : (
    index += 1;
  );
  selected_note = -1;
  while (index <= synthx_max_active_note && selected_note < 0) (
    note = synthx_notestack + synthx_step*index;
    note[0/*NOTE:ACTIVE*/] && note[2/*NOTE:SAMPLES_FROM_ATTACK*/] >= 0 ? (
      selected_note = note + synthx_custom_offset;
    );
    index += 1;
  );
  selected_note;
);

function synth_note_first() (
  synth_note_next(-1);
);

function synth_needs_init(note) (
  note -= synthx_custom_offset;
  note[8/*NOTE:CUSTOM_INIT*/] ? (
    0;
  ) : (
    note[8/*NOTE:CUSTOM_INIT*/] = 1;
  );
);

function synth_stop(note) (
  (note - synthx_custom_offset)[0/*NOTE:ACTIVE*/] = 0;
);

function synth_midinote(note) (
  (note - synthx_custom_offset)[4/*NOTE:NOTE*/];
);

function synth_freq(note) (
  (note - synthx_custom_offset)[5/*NOTE:BASE_FREQ*/]*synthx_pitchbend_ratio;
);

function synth_velocity(note) (
  (note - synthx_custom_offset)[6/*NOTE:VEL*/];
);

function synth_channel(note) (
  (note - synthx_custom_offset)[7/*NOTE:CHANNEL*/];
);

function synth_pitchbend() (
  synthx_pitchbend;
);

function synth_attack(note) (
  (note - synthx_custom_offset)[2/*NOTE:SAMPLES_FROM_ATTACK*/];
);

function synth_attack_seconds(note) (
  (note - synthx_custom_offset)[2/*NOTE:SAMPLES_FROM_ATTACK*/]*synthx_timestep;
);

function synth_release(note) (
  (note - synthx_custom_offset)[1/*NOTE:SAMPLES_FROM_RELEASE*/];
);

function synth_sustain_release(note) (
  (note - synthx_custom_offset)[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/];
);

function synth_release_seconds(note) (
  (note - synthx_custom_offset)[1/*NOTE:SAMPLES_FROM_RELEASE*/]*synthx_timestep;
);

function synth_sustain_release_seconds(note) (
  (note - synthx_custom_offset)[3/*NOTE:SAMPLES_FROM_SUSTAIN_RELEASE*/]*synthx_timestep;
);

function synth_controller(number) (
  synthx_controllers[number];
);


freemem = 0;
freemem = synth_init(freemem, 1,pbrange); // Request one slot to keep the phase in



//for the clipper
ext_tail_size = -2;
 
amp_dB = 8.6562;
baseline_threshold_dB = -9.0;
cl_a = 1.017;
cl_b = -0.025;
//sub

@slider
nattack=attack;

nrelease=release;
nsineV=sineV;
nsawV=sawV;
nsquareV=squareV;
ntriV=triV;
nsupV=supV;
nsubV=subV;

npbrange=pbrange;
(nnpbrange!=npbrange)?(
  freemem = 0;
  freemem = synth_init(freemem, 1,npbrange); // Request one slot to keep the phase in
  nnpbrange=npbrange;
);
//(npbrange!=nnpbrange)?(
//npbrange=nnpbrange; 
//);
setsup=supset;
setsub=subset;


attack_samples = nattack*srate;

release_samples = nrelease*srate;
//hpf
hpf_freq=hpff;
hpf_tmp2=max(min(hpff,7350),0);
hpf_tmp=max(min(hpfr,0.99),0);
hpf_q=hpf_tmp;
hpf_freq=hpf_tmp2;
hpf_f = 2.0*sin($pi*hpf_freq/srate);
hpf_fb = hpf_q + hpf_q/(1.0 - hpf_f);

hpf_gain=1;

//lpf
lpf_freq=lpff;
lpf_tmp2=max(min(lpff,16000),20);
lpf_tmp=max(min(lpfr,0.99),0);
lpf_q=lpf_tmp;
lpf_freq=lpf_tmp2;
lpf_f = 2.0*sin($pi*lpf_freq/srate);
lpf_fb = lpf_q + lpf_q/(1.0 - lpf_f);

lpf_gain=1;

//for the clipper
boost_dB = cl_boost;
limit_dB = cl_wall;
threshold_dB = baseline_threshold_dB + limit_dB;


@block 

synth_block();

@sample

synth_sample();

// Iterate over the active notes
note = synth_note_first();
while (note > 0) (
  // We have 1 slot available to use
  //   because that's what we asked for in synth_init()
  note[0] += synth_freq(note)/srate;
  
  phase = note[0]*2*$pi;
  amp = 0.25;
  amp *= synth_velocity(note)/127;
  amp *= synth_controller(11)/127;
  attack_samples && synth_attack(note) < attack_samples ? (
    amp *= synth_attack(note)/attack_samples;
  );
  
  
  release_samples && synth_release(note) > 0 ? (
    amp *= 1 - synth_release(note)/release_samples;
  );
   //sine
  (nsineV >0) |( spl0 +=sin(phase)*amp*nsineV*1.2);
  (nsubV >0) |( sub0 += sin((phase)/setsub)*amp*nsineV*1.2*nsubV) ;
  (nsupV >0) |( sup0 += sin((phase)*setsup)*amp*nsineV*1.2*nsupV) ;
  
  // sawtooth
  (nsawV >0)| (spl0 += atan(tan(phase/2))*amp*nsawV*0.9);
  (nsubV >0)| (sub0 += atan(tan(phase/2/setsub))*amp*nsawV*0.9*nsubV);
  (nsupV >0)| (sup0 += atan(tan(phase/2*setsup ))*amp*nsawV*0.9*nsupV);
  
  //Squarewave-ish
  (nsquareV>0)|(
    m=1;
    rr=24;
    while (m<rr)(
      spl0 += sin(phase*m)*amp*(rr/m)*nsquareV*0.05;
      m+=2;
    );
    
  );
  (nsubV>0)|(
    m=1;
    rr=24;
    while (m<rr)(
      sub0 += sin(phase*m/setsub)*amp*(rr/m)*nsquareV*nsubV*0.05;           
      m+=2;
      );
    );
  (nsupV>0)|(
    m=1;
    rr=24;
    while (m<rr)(
      sup0 += sin(phase*m*setsup)*amp*(rr/m)*nsquareV*nsupV*0.05;           
      m+=2;
      );
    );  
  
  (ntriV>0)|(
    
    spl0 += sin(phase)*amp*ntriV;           
    spl0 += sin(phase*3)*amp*ntriV*-0.1;           
    spl0 += sin(phase*5)*amp*ntriV*+0.05;           
    spl0 += sin(phase*7)*amp*ntriV*-0.025;           
    spl0 += sin(phase*9)*amp*ntriV*+0.0125;           
    spl0 *=0.8;
    
    );
  
  (nsubV>0)|(
    sub0 += sin(phase/setsub)*amp*ntriV*nsubV;                
    sub0 += sin(phase*3/setsub)*amp*ntriV*-0.1*nsubV;           
    sub0 += sin(phase*5/setsub)*amp*ntriV*+0.05*nsubV;             
    sub0 += sin(phase*7/setsub)*amp*ntriV*-0.025*nsubV;           
    sub0 += sin(phase*9/setsub)*amp*ntriV*+0.0125*nsubV;           
    sub0 *=0.5;
    );
  (nsupV>0)|(
    sup0 += sin(phase*setsup)*amp*ntriV*nsubV;                
    sup0 += sin(phase*3*setsup)*amp*ntriV*-0.1*nsupV;           
    sup0 += sin(phase*5*setsup)*amp*ntriV*+0.05*nsupV;             
    sup0 += sin(phase*7*setsup)*amp*ntriV*-0.025*nsupV;           
    sup0 += sin(phase*9*setsup)*amp*ntriV*+0.0125*nsupV;           
    sup0 *=0.5;
    );
  
  
  
  synth_release(note) >= release_samples ? (
    synth_stop(note);
  );

  note = synth_note_next(note);
);
//hpf
spl0+=sup0; //add sup
spl0+=sub0; //add sub
hpf_inA=spl0;
hpf_hpA = hpf_inA - hpf_buf0A;
hpf_bpA = hpf_buf0A - hpf_buf1A;
hpf_buf0A = hpf_buf0A + hpf_f * (hpf_hpA + hpf_fb * hpf_bpA);
hpf_buf1A = hpf_buf1A + hpf_f * (hpf_buf0A - hpf_buf1A);
(hpff>0)?(spl0=hpf_hpA*hpf_gain;);

//lpf
lpf_inA=spl0;
lpf_hpA = lpf_inA - lpf_buf0A;
lpf_bpA = lpf_buf0A - lpf_buf1A;
lpf_buf0A = lpf_buf0A + lpf_f * (lpf_hpA + lpf_fb * lpf_bpA);
lpf_buf1A = lpf_buf1A + lpf_f * (lpf_buf0A - lpf_buf1A);
(lpff<16000)?(spl0=lpf_buf1A*lpf_gain;);

// the clipper
dB0 = amp_dB * log(abs(spl0)) + boost_dB;


(dB0 > threshold_dB) ? (
  over_dB = dB0 - threshold_dB;
  over_dB = cl_a * over_dB + cl_b * over_dB * over_dB;
  dB0 = min(threshold_dB + over_dB, limit_dB);
);



spl0 = exp(dB0 / amp_dB) * sign(spl0);
    // fill the other side 
  spl1=spl0;

@gfx 1000 20
bg=gfx_getsyscol();
gfx_clear=bg;
gfx_r=gfx_g=gfx_b=0.5;
gfx_x=gfx_y=0;
gfx_drawstr("(simple synth bobobo) no gui");


